use readable;
use readable::HeadExpression::*;

grammar;

pub Line: readable::Line = {
    <Fun> => readable::Line::Function(<>),
    <Annotation> => readable::Line::Annotation(<>),
};

pub Fun: readable::Function = {
    <fname:Name> <vars:Var*> "=" <body:Expr>
        => readable::Function {<>},
};

Var: readable::Annotation = {
    "(" <Annotation> ")",
    <name: Name> => {
        let head = readable::HeadExpression::Point;
        let head = Box::new(head);
        let tail = Vec::new();
        let typ = readable::Expression { head, tail };
        readable::Annotation { name, typ }
    },
};

pub Annotation: readable::Annotation = {
    <name: Name> ":" <typ: Expr> => readable::Annotation {<>},
};

pub Expr: readable::Expression = {
    CommaFreeExpr,
    <CommaExpr> => readable::Expression {
        head: Box::new(<>),
        tail: Vec::new(),
    },
};

pub CommaExpr: readable::HeadExpression = {
    "Sigma" <Name> ":" <CommaFreeExpr> "," <Expr> => Sigma(<>),
    "Pi" <Name+> ":" <CommaFreeExpr> "," <Expr> => Pi(<>),
    <CommaFreeExpr> "->" <Expr> => Pi(vec!["_".into()], <>),
};

CommaFreeExpr: readable::Expression = {
    <head:HeadExprBox> <tail:TailExpr*> => readable::Expression {<>},
    "(" <Expr> ")",
};

HeadExprBox: Box<readable::HeadExpression> = {
    HeadExpr => Box::new(<>),
};

HeadExpr: readable::HeadExpression = {
    Name => Name(<>.into()),

    "void_elim" <TailExpr> => VoidElim(<>),

    "tt" => Point,
    "unit_elim" <TailExpr> => UnitElim(<>),

    "true" => True,
    "false" => False,
    "bool_elim" <TailExpr> => BoolElim(<>),

    "pair" <TailExpr> <TailExpr> => Pair(<>),
    "sigma_elim" <TailExpr> <TailExpr> <TailExpr> => SigmaElim(<>),

    "Void" => Void,
    "Unit" => Unit,
    "Bool" => Bool,

    "Type" => Type,

    "fix" <TailExpr> => Fix(<>),
};

TailExpr: readable::Expression = {
    "(" <Expr> ")",
    <head:HeadExprBox> => readable::Expression { <>, tail: Vec::new() },
};


Name: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*'*" => <>.into(),
};
